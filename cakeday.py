import sqlite3
import praw
from datetime import datetime, timezone, timedelta
import time
from google import genai  # Import the genai library
from pytz import timezone as pytz_timezone  # Rename pytz's timezone to avoid conflicts
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer  # Import sentiment analyzer
from config import CLIENT_ID, CLIENT_SECRET, USER_AGENT, REDDIT_USERNAME, REDDIT_PASSWORD, DATABASE_NAME, API_CALL_DELAY, GEMINI_API_KEY  # Import global variables

# Register custom adapter and converter for DATE type
def adapt_date(date_obj):
    return date_obj.isoformat()  # Convert date to ISO 8601 string

def convert_date(date_str):
    return datetime.strptime(date_str, "%Y-%m-%d").date()  # Convert ISO 8601 string back to date

sqlite3.register_adapter(datetime.date, adapt_date)
sqlite3.register_converter("DATE", convert_date)

def get_reddit_instance():
    reddit = praw.Reddit(
        client_id=CLIENT_ID,
        client_secret=CLIENT_SECRET,
        user_agent=USER_AGENT,
        username=REDDIT_USERNAME,
        password=REDDIT_PASSWORD
    )
    return reddit

def get_gemini_client():
    return genai.Client(api_key=GEMINI_API_KEY)

def post_cake_day_comment(reddit_obj, target_obj, gemini_message):
    """
    Posts the generated Cake Day message as a comment.

    Args:
        reddit_obj: The PRAW Reddit instance.
        target_obj: The PRAW object to reply to (either a Post or a Comment).
        gemini_message: The message generated by Gemini.
    """
    try:
        comment_text = f"{gemini_message}\n\n*I am a bot sending some cheer in a world that needs more. Run by /u/LordTSG*"
        target_obj.reply(comment_text)
        print(f"    üí¨ Posted comment to {target_obj.author.name if target_obj.author else 'deleted user'}: {gemini_message}")
        print(f"    üîó URL: http://reddit.com{target_obj.permalink}\n")
              
    except Exception as e:
        print(f"    ‚ö†Ô∏è Error posting comment: {e}")

def _get_title_context(context_type, post_title):
    if context_type == "comment":
        return f"The comment is in a post titled '{post_title}'. "
    else:
        return f"The post is titled '{post_title}'. "

def has_been_wished(username):
    conn = sqlite3.connect(DATABASE_NAME, detect_types=sqlite3.PARSE_DECLTYPES)
    cursor = conn.cursor()
    today = datetime.now().date()

    # Check if the user has been wished today
    cursor.execute("SELECT wished_date FROM wished_users WHERE username = ?", (username,))
    result = cursor.fetchone()

    if result:
        wished_date = result[0]
        if isinstance(wished_date, str):  # Ensure the date is converted if stored as a string
            wished_date = datetime.strptime(wished_date, "%Y-%m-%d").date()

        if wished_date == today:  # User has already been wished today
            conn.close()
            return True
        else:  # User's cake day has passed, remove them from the table
            cursor.execute("DELETE FROM wished_users WHERE username = ?", (username,))
            conn.commit()

    conn.close()
    return False

def mark_as_wished(username):
    conn = sqlite3.connect(DATABASE_NAME)
    cursor = conn.cursor()
    today = datetime.now().date().isoformat()  # Convert to ISO 8601 string
    cursor.execute("INSERT OR REPLACE INTO wished_users (username, wished_date) VALUES (?, ?)", (username, today))
    conn.commit()
    conn.close()

def is_cake_day(reddit, username):
    try:
        if has_been_wished(username):
            print(f"    ‚è≠Ô∏è  Skipping {username}, already wished today.")
            return False

        redditor = reddit.redditor(username)
        if not hasattr(redditor, 'created_utc'):
            print(f"      ‚ö†Ô∏è  Warning: Unable to retrieve 'created_utc' for user: {username}")
            return False

        account_creation_time = datetime.fromtimestamp(redditor.created_utc, timezone.utc)  # Use datetime's timezone.utc
        now_local = datetime.now(pytz_timezone('America/Toronto'))  # Use pytz's timezone for local time

        if (now_local - account_creation_time).days >= 365:  # Check if the account is at least 1 year old
            # Check if today is the exact anniversary of the account creation
            if (account_creation_time.month == now_local.month and
                account_creation_time.day == now_local.day):
                mark_as_wished(username)
                return True

        return False
    except Exception as e:
        print(f"      ‚ö†Ô∏è Error checking Cake Day for user {username}: {e}")
        return False

def analyze_sentiment(text):
    """
    Analyze the sentiment of a given text using Vader SentimentIntensityAnalyzer.

    Args:
        text (str): The text to analyze.

    Returns:
        str: The overall sentiment ('positive', 'neutral', or 'negative').
    """
    analyzer = SentimentIntensityAnalyzer()
    sentiment_scores = analyzer.polarity_scores(text)
    if sentiment_scores['compound'] >= 0.05:
        return "positive"
    elif sentiment_scores['compound'] <= -0.05:
        return "negative"
    else:
        return "neutral"

def process_item(reddit, item, item_type, subreddit_name, post_title=None):
    """
    Processes a Reddit item (Post or Comment) to check for Cake Day and post a message.

    Args:
        reddit: The PRAW Reddit instance.
        item: The Reddit item to process (either a Post or a Comment).
        item_type: A string indicating the item type ('post' or 'comment').
        subreddit_name: The name of the subreddit.
        post_title: The title of the post (only applicable for comments).
    """
    if item.author and is_cake_day(reddit, item.author.name):
        account_creation_date = datetime.fromtimestamp(reddit.redditor(item.author.name).created_utc, timezone.utc)
        account_age_years = (datetime.now(timezone.utc) - account_creation_date).days // 365
        print(f"  üéâ Cake Day found for user: {item.author.name} (Account Age: {account_age_years} years) on their {item_type}:")

        item_score = f"{item.score:+}"  # Get the score of the current item with "+" or "-" prefix

        # Collect context for the Gemini prompt
        comment_chain_context = []
        try:
            if item_type == "comment":
                # Traverse the comment tree for relevant context
                parent = item.parent()
                if parent:
                    parent_text = parent.body[:250] if hasattr(parent, "body") else (parent.selftext[:250] if hasattr(parent, "selftext") else "(no text content)")
                    parent_sentiment = analyze_sentiment(parent_text)
                    comment_chain_context.append({
                        "author": parent.author.name if parent.author else "[deleted]",
                        "text": parent_text,
                        "type": "post" if isinstance(parent, praw.models.Submission) else "comment",
                        "post_hint": parent.post_hint if hasattr(parent, "post_hint") else None,
                        "sentiment": parent_sentiment,
                        "reddit_score": f"{parent.score:+}" if isinstance(parent, praw.models.Comment) else f"{parent.score:+}",  # Add "+" or "-" prefix
                        "is_cake_day": parent.author.name == item.author.name if parent.author else False
                    })
                # Add the current comment
                current_text = item.body[:250]
                current_sentiment = analyze_sentiment(current_text)
                comment_chain_context.append({
                    "author": item.author.name,
                    "text": current_text,
                    "type": "comment",
                    "post_hint": item.post_hint if hasattr(item, "post_hint") else None,
                    "sentiment": current_sentiment,
                    "reddit_score": item_score,  # Add "+" or "-" prefix
                    "is_cake_day": True
                })
                # Add sibling comments (limit to 5-10 total comments)
                if isinstance(parent, praw.models.Comment):  # Ensure parent is a Comment
                    siblings = parent.replies
                    for sibling in siblings[:8]:
                        if sibling != item:
                            sibling_text = sibling.body[:250] if hasattr(sibling, "body") else "(no text content)"
                            sibling_sentiment = analyze_sentiment(sibling_text)
                            comment_chain_context.append({
                                "author": sibling.author.name if sibling.author else "[deleted]",
                                "text": sibling_text,
                                "type": "comment",
                                "post_hint": sibling.post_hint if hasattr(sibling, "post_hint") else None,
                                "sentiment": sibling_sentiment,
                                "reddit_score": f"{sibling.score:+}",  # Add "+" or "-" prefix
                                "is_cake_day": sibling.author.name == item.author.name if sibling.author else False
                            })
            elif item_type == "post":
                # Add the post's selftext and top comments
                post_text = item.selftext[:250] if item.selftext else "(no text content)"
                post_sentiment = analyze_sentiment(post_text)
                comment_chain_context.append({
                    "author": item.author.name,
                    "text": post_text,
                    "type": "post",
                    "post_hint": item.post_hint if hasattr(item, "post_hint") else None,
                    "sentiment": post_sentiment,
                    "reddit_score": item_score,  # Add "+" or "-" prefix
                    "is_cake_day": True
                })
                for top_comment in item.comments[:9]:
                    top_comment_text = top_comment.body[:250] if hasattr(top_comment, "body") else "(no text content)"
                    top_comment_sentiment = analyze_sentiment(top_comment_text)
                    comment_chain_context.append({
                        "author": top_comment.author.name if top_comment.author else "[deleted]",
                        "text": top_comment_text,
                        "type": "comment",
                        "post_hint": top_comment.post_hint if hasattr(top_comment, "post_hint") else None,
                        "sentiment": top_comment_sentiment,
                        "reddit_score": f"{top_comment.score:+}",  # Add "+" or "-" prefix
                        "is_cake_day": top_comment.author.name == item.author.name if top_comment.author else False
                    })
        except Exception as e:
            print(f"    ‚ö†Ô∏è Error collecting comment chain context: {e}")

        # Calculate sentiment statistics
        sentiment_scores = [analyze_sentiment(entry["text"]) for entry in comment_chain_context]
        analyzer = SentimentIntensityAnalyzer()  # Create an instance of SentimentIntensityAnalyzer
        average_sentiment_score = sum([analyzer.polarity_scores(entry["text"])["compound"] for entry in comment_chain_context]) / len(comment_chain_context)
        most_extreme_sentiment = max(comment_chain_context, key=lambda x: abs(analyzer.polarity_scores(x["text"])["compound"]))
        sentiment_trend = "positive" if average_sentiment_score > 0 else "negative" if average_sentiment_score < 0 else "neutral"

        # Construct the Gemini prompt
        gemini_message_prompt = f"""
        You are a Reddit bot that celebrates users' Cake Days. Your goal is to craft a clever or witty, but most important: in-context, cake day wish for a user based on the surrounding conversation in a Reddit thread.
        
        Here is the information about the context:

        Subreddit: r/{subreddit_name}
        Post Title: {post_title if post_title else item.title}
        Relevant Comment Chain:
        {comment_chain_context}

        Sentiment Analysis:
        - Average Sentiment Score: {average_sentiment_score:.2f} (Sentiment range is -1 to 1, -1 being very negative and 1 being very positive)
        - Most Extreme Sentiment: {most_extreme_sentiment["sentiment"]} (Text: "{most_extreme_sentiment["text"]}")
        - Sentiment Trend: {sentiment_trend}

        The user celebrating their Cake Day is "{item.author.name}". The user is {account_age_years} year{"s" if account_age_years > 1 else ""} old. Include their age somewhere in the cake day wish. This user is the {'post author' if item_type == 'post' else 'comment author'}.
        Craft a cake day wish for "{item.author.name}" that is relevant to the topic and tone of the post title and the surrounding comments. Use the sentiment analysis (average sentiment, most extreme sentiment, and sentiment trend) to guide the tone of your message.
        Also, consider the Reddit score of the post/comments when generating the message. High scoring posts/comments are generally well-received by the community.

        Your response should *only* be the cake day wish text, suitable for posting as a reply to the {'post' if item_type == 'post' else 'comment'}.
        """

        # Call Gemini API to generate the message
        print(f"""    
            Subreddit: r/{subreddit_name}
            Post Title: {post_title if post_title else item.title}
            Relevant Comment Chain:\n
              {comment_chain_context}\n
            Sentiment Analysis:
              - Average Sentiment Score: {average_sentiment_score:.2f} 
              - Most Extreme Sentiment: {most_extreme_sentiment["sentiment"]} (Text: "{most_extreme_sentiment["text"]}")
              - Sentiment Trend: {sentiment_trend}
        """)

        client = get_gemini_client()
        try:
            response = client.models.generate_content(
                model="gemini-2.0-flash",  # Or whichever Gemini model you are using
                contents=gemini_message_prompt,
            )
            gemini_message = response.text
        except Exception as e:
            print(f"    ‚ö†Ô∏è  Error calling Gemini API: {e}")
            gemini_message = "Happy Cake Day!"  # Provide a fallback message

        # Post the Cake Day wish
        post_cake_day_comment(reddit, item, gemini_message)
        return True  # Indicate that a Cake Day was found
    return False  # Indicate no Cake Day was found

def process_subreddit(reddit, subreddit_name, last_post_checked):
    subreddit = reddit.subreddit(subreddit_name)
    new_last_post_checked = None  # Initialize as None
    cake_day_count = 0  # Counter for cake days found

    posts = subreddit.new(limit=25)  # Check the 25 newest posts (adjust as needed)

    for post in posts:
        if not new_last_post_checked:
            new_last_post_checked = post.id  # Set to the first post checked

        if last_post_checked and post.id == last_post_checked:
            break  # We've reached the last checked post

        if post.author:
            print(f"  Checking post: '{post.title}' by {post.author.name} with {post.num_comments} comments. Please stand by...")
            if process_item(reddit, post, "post", subreddit_name):
                cake_day_count += 1  # Increment only if a Cake Day was found
            time.sleep(API_CALL_DELAY)  # Be mindful of rate limits

        post.comments.replace_more(limit=None)  # Load all top-level comments
        for comment in post.comments.list():
            if comment.author:
                if process_item(reddit, comment, "comment", subreddit_name, post.title):
                    cake_day_count += 1  # Increment only if a Cake Day was found
                time.sleep(API_CALL_DELAY)

    print(f"  üéâ Total Cake Days found in r/{subreddit_name}: {cake_day_count} {"" if cake_day_count == 0 else "üéâüéâ"}")
    return new_last_post_checked

def get_subreddit_info_from_database():
    conn = sqlite3.connect(DATABASE_NAME)
    cursor = conn.cursor()
    cursor.execute("SELECT subreddit_name, last_post_checked FROM subreddits")
    subreddit_info = {row[0]: row[1] for row in cursor.fetchall()}
    conn.close()
    return subreddit_info

def update_last_post_checked(subreddit_name, last_post_checked):
    conn = sqlite3.connect(DATABASE_NAME)
    cursor = conn.cursor()
    cursor.execute("UPDATE subreddits SET last_post_checked = ? WHERE subreddit_name = ?", (last_post_checked, subreddit_name))
    conn.commit()
    conn.close()

def update_scan_time(subreddit_name):
    conn = sqlite3.connect(DATABASE_NAME)
    cursor = conn.cursor()
    now_utc = datetime.now(timezone.utc)
    timestamp_numeric = now_utc.timestamp()
    cursor.execute("UPDATE subreddits SET last_scan_time = ? WHERE subreddit_name = ?", (timestamp_numeric, subreddit_name))
    conn.commit()
    conn.close()

def clear_expired_wished_users():
    """Remove users from the wished_users table whose cake day has passed."""
    conn = sqlite3.connect(DATABASE_NAME)
    cursor = conn.cursor()
    today = datetime.now().date().isoformat()  # Get today's date in ISO 8601 format
    cursor.execute("DELETE FROM wished_users WHERE wished_date < ?", (today,))
    conn.commit()
    conn.close()

def get_bot_comment_score(reddit, subreddit_name):
    """
    Calculate the overall score of the bot's comments in a subreddit.

    Args:
        reddit: The PRAW Reddit instance.
        subreddit_name: The name of the subreddit.

    Returns:
        int: The total score of the bot's comments in the subreddit.
    """
    try:
        bot_user = reddit.redditor(REDDIT_USERNAME)  # Get the bot's user profile
        total_score = 0

        # Fetch the bot's comments and filter by subreddit
        for comment in bot_user.comments.new(limit=None):  # Fetch all recent comments by the bot
            if comment.subreddit.display_name.lower() == subreddit_name.lower():
                total_score += comment.score

        return total_score
    except Exception as e:
        print(f"    ‚ö†Ô∏è Error fetching bot comments for r/{subreddit_name}: {e}")
        return 0

if __name__ == "__main__":
    clear_expired_wished_users()  # Clear expired wished users at the start
    start_time = time.time()  # Store the start timestamp
    reddit_time = time.time() # Store the start timestamp to time each reddit scan
    reddit = get_reddit_instance()
    subreddit_info = get_subreddit_info_from_database()

    if not subreddit_info:
        print("No subreddits found in the database.")
    else:
        print("Scanning subreddits for Cake Days...")
        for subreddit_name, last_post_checked in subreddit_info.items():
            # Calculate the bot's overall score in the subreddit
            bot_score = get_bot_comment_score(reddit, subreddit_name)
            print(f"\nScanning r/{subreddit_name}... (overall score: {bot_score:+})")

            new_last_post_checked = process_subreddit(reddit, subreddit_name, last_post_checked)
            update_last_post_checked(subreddit_name, new_last_post_checked)
            update_scan_time(subreddit_name)

            # Calculate and print elapsed time
            total_elapsed_time = time.time() - start_time
            hours, remainder = divmod(total_elapsed_time, 3600)
            minutes, seconds = divmod(remainder, 60)

            reddit_elapsed_time = time.time() - reddit_time
            rhours, rremainder = divmod(reddit_elapsed_time, 3600)
            rminutes, rseconds = divmod(rremainder, 60)

            print(f"  ‚úÖ Finished scanning r/{subreddit_name}. Time taken to scan: {int(rhours)}h {int(rminutes)}m {rseconds:.2f}s")
            print(f"  üïí Total time taken: {int(hours)}h {int(minutes)}m {seconds:.2f}s")

            reddit_time = time.time()  # Reset the Reddit scan timer for the next subreddit

    print("\nScan complete.")